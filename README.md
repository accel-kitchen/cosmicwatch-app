# CosmicWatch Recorder - Web App

> Webブラウザで完結する、CosmicWatchデータロガー＆アナライザー

**CosmicWatch Recorder**は、放射線検出器[CosmicWatch](http://cosmicwatch.lns.infn.it/)からのデータを、PCに接続するだけでリアルタイムに記録・可視化・管理できる**Webアプリケーション**です。プログレッシブウェブアプリ（PWA）技術により、オフライン利用やホーム画面へのインストールも可能です。

## ✨ 主な機能

*   **インストール不要:** URLにアクセスするだけで、すぐに利用を開始できます。
*   **リアルタイム全体像表示:** 長時間測定でもパフォーマンスを損なうことなく、測定開始から現在までの全期間の推移グラフをリアルタイムで表示します。
*   **高精度なデータ記録:** CosmicWatchから送られてくる情報を欠落させることなく、すべて記録します。
*   **セッションベースのデータ管理:** 測定を「セッション」として管理。過去の測定データをいつでも呼び出して詳細に分析できます。
*   **自動データ永続化:** 記録したデータはすべて、お使いのブラウザ内のデータベース(IndexedDB)に自動で保存されます。
*   **オフライン対応:** 一度アクセスすれば、インターネット接続がない環境でもアプリの起動やデータ記録・閲覧が可能です。
*   **データ主権:** 記録したデータは、いつでも`.dat` (TSV) 形式でエクスポートしたり、外部からインポートしたりできます。
*   **多言語対応:** UIを日本語と英語で切り替え可能です。

## 🚀 クイックスタート

1.  **ブラウザでアクセス**: [https://accel-kitchen.com/app/cosmicwatch-app/](https://accel-kitchen.com/app/cosmicwatch-app/)
2.  **CosmicWatchを接続**: USBケーブルでPCに接続します。
3.  **シリアルポートを選択**: アプリ内の「接続」ボタンを押し、表示された一覧からCosmicWatchのポートを選択します。
4.  **測定開始**: 自動的にデータ記録とグラフ描画が開始されます。データはブラウザに自動保存されます。

> 💡 **ホーム画面に追加 (PWA機能)**
> アドレスバーの「インストール」アイコンをクリックすると、ネイティブアプリのようにデスクトップやホーム画面から直接起動できるようになります。

## 📖 使用方法

1.  **新規セッションの開始:**
    *   「新規セッション」ボタンを押し、セッション名やメモ、タグなどを設定して記録を開始します。
2.  **データ測定と監視:**
    *   記録画面で、リアルタイムのヒストグラムや時系列グラフ、統計情報を監視します。
    *   測定は「一時停止」「再開」「終了」が可能です。
3.  **過去のセッションの確認:**
    *   「セッション一覧」から過去のデータを呼び出し、詳細な分析やグラフの確認ができます。
4.  **データの入出力:**
    *   各セッションは、詳細画面の「エクスポート」ボタンから`.dat`ファイルとしてダウンロードできます。
    *   ヘッダーの「インポート」から、`.dat`ファイルを読み込めます。

## 🔧 トラブルシューティング

### 接続できない場合
1.  **対応ブラウザか確認:** Google Chrome, Microsoft Edge など、Web Serial APIに対応したブラウザを使用してください (Safariは非対応です)。
2.  **ポートの確認:** 他のアプリケーション（Arduino IDEなど）がシリアルポートを使用していないか確認してください。
3.  **再接続:** ブラウザをリロードし、CosmicWatchをPCに再接続してみてください。

---

# アプリケーション仕様書

## 1. アーキテクチャ原則

*   **クライアント中心設計:** アプリケーションのロジックとデータストレージは、完全にクライアントサイドで完結する。
*   **責務の分離 (SoC):**
    *   **UI状態 (Redux):** アプリケーションの一時的なUIの状態のみを管理する。
    *   **永続データ (IndexedDB):** 全てのユーザーデータを管理する唯一の信頼できる情報源 (Source of Truth) とする。
*   **パフォーマンス・バイ・デザイン:** 大規模データセットとリアルタイム描画を両立するため、データ仮想化や動的リサンプリング戦略を設計の核に据える。
*   **無損失データ:** CosmicWatchから受信した元データは、解析の都合で省略せず、すべてを忠実に記録する。

## 2. 技術スタック

| カテゴリ           | 技術・ライブラリ                     | 目的と選定理由                                     |
| :----------------- | :----------------------------------- | :------------------------------------------------- |
| **UIフレームワーク**   | React 19, React DOM                | 宣言的なUI構築と豊富なエコシステム。               |
| **ビルドツール**       | Vite                                 | 高速な開発サーバーと最適化された本番ビルド。       |
| **言語**           | TypeScript                           | 型安全性によるコード品質と保守性の向上。           |
| **状態管理**       | Redux Toolkit                        | アプリケーション全体のUI状態を予測可能に管理。     |
| **データ永続化**     | IndexedDB (via **Dexie.js**)       | 大規模な構造化データをクライアントサイドで扱うためのデファクトスタンダード。 |
| **ルーティング**       | React Router                         | SPAの画面遷移を管理。                              |
| **スタイリング**     | Tailwind CSS                         | ユーティリティファーストによる迅速なUI実装。       |
| **グラフ描画**       | Plotly.js                            | 高機能・インタラクティブなグラフ描画、データ仮想化に対応。 |
| **ハードウェア連携** | Web Serial API                       | ブラウザからシリアルポート経由でデバイスと直接通信。 |
| **多言語化**       | `i18next`, `react-i18next`           | 高機能でデファクトスタンダードなi18nフレームワーク。言語検出、リソース読み込み、UI更新を柔軟に管理。 |

## 3. リアルタイム処理アーキテクチャ

### 3.1. 基本方針: UI更新と永続化の完全分離

リアルタイムUIの更新はすべて高速なメモリ上のデータで行い、IndexedDBへの書き込みはUIをブロックしないバックグラウンド処理として実行する。

### 3.2. ライブ全体推移グラフの実現: 動的リサンプリング方式

「測定開始から現在までの全期間」にわたるカウントレートの推移をリアルタイムで表示するため、**動的リサンプリング (Automatic Downsampling)** アーキテクチャを採用する。

*   **アルゴリズム:**
    1.  Reduxストアで、グラフ描画専用のデータ配列 `plotData` (最大要素数`N`) と、現在の集計ビン`currentBin`、ビンの期間`binDuration`を管理する。
    2.  新しいデータが来たら`currentBin`のカウントを増やす。
    3.  ビンが確定したら`plotData`に新しい点を追加する。
    4.  `plotData`の長さが`N`を超えたら、`plotData`の隣接する2点を1つにマージして配列長を半分にし、`binDuration`を2倍にする。
*   **メリット:** セッションの最初から最後まで、パフォーマンスを維持したまま常に全体像を把握できる。

### 3.3. パフォーマンス制御: 統計のON/OFF機能

ユーザーが任意にリアルタイム統計処理の有効/無効を切り替えられる機能を実装する。

*   **統計ONの場合:** 動的リサンプリングやADCヒストグラムの計算が実行される。
*   **統計OFFの場合:** これらの統計処理は完全にスキップされ、CPU・メモリ負荷を最小化する。
*   **共通処理:** ON/OFFに関わらず、受信した生のデータポイントは常にバックグラウンドでIndexedDBに永続化される。

## 4. データ構造設計 (IndexedDB)

*   **データベース名:** `AppDB_v5` (マイグレーションを考慮)

### 4.1. `sessions` ストア
記録セッションのメタデータを管理する。
*   `id, name, description, status, createdAt, startedAt, endedAt, tags, config`
*   `stats`: セッション完了時に計算される最終統計情報 (`{ dataPointCount, durationMs, adc: { min, max, avg }, ... }`)

### 4.2. `data_points` ストア
CosmicWatchから送られてくる情報を欠落なく格納する。
*   `id`: `++id` (Primary Key)
*   `sessionId`: `number`
*   `timestamp`: `number` (クライアント側高精度タイムスタンプ)
*   `adc`: `number`
*   `deviceEventId`: `number`
*   `deviceTime`: `number | string`
*   `temp, sipm, deadtime, humidity, pressure`: `number | null`
*   **インデックス:** `++id`, `sessionId`, `[sessionId+timestamp]`, `[sessionId+adc]`

## 5. 機能仕様詳細

### 5.1. 過去データの分析

*   **データソース:** 過去セッションの分析画面では、リアルタイム表示で使ったリサンプリング後のデータではなく、**IndexedDBに保存されている生の`data_points`を都度クエリ**して使用する。
*   **集計単位:** ユーザーはグラフの集計単位（1分、5分、10分、1時間など）をUI上で選択できる。
*   **処理:** 選択された集計単位に基づき、その場でビン集計を行い、インタラクティブなグラフ（ズーム、パン対応）を描画する。

### 5.2. データ入出力 (.dat形式)

データの可搬性と、他の解析ツール（Excel, Python/Pandasなど）との互換性を重視し、旧バージョンと同様のタブ区切り形式（`.dat`）を採用する。

*   **基本方針:**
    *   **エンコーディング:** UTF-8
    *   **区切り文字:** タブ (`\t`)
    *   **コメント:** 行頭が `#` の行はコメントまたはメタデータとして扱う。

*   **エクスポート仕様:**
    *   **ファイル構造:**
        1.  **メタデータ部:**
            *   ファイルの先頭に、`#` で始まるコメント行としてセッションのメタデータをキー・バリュー形式で記述する。
            *   例:
                ```
                # Session Name: 2024-08-01 BG Measurement
                # Description: Study room, no external source.
                # Start Time: 2024-08-01T10:00:00.000Z
                # End Time: 2024-08-01T12:00:00.000Z
                # Tags: background, study
                # Config: {"dataSourceType":"serial","serialConfig":{"baudRate":9600}}
                ```
        2.  **カラム定義ヘッダー:**
            *   データ部の直前に、カラムの順序を示すヘッダー行を `#` 付きのコメントとして挿入する。
            *   例: `# timestamp\tadc\ttemp\t...`
        3.  **データ部:**
            *   `data_points`ストアの各レコードを1行として、上記ヘッダーで定義された順序で出力する。
            *   `null` の値は空文字列として出力する。

*   **インポート仕様:**
    *   **パーサーの挙動:**
        1.  ファイルを1行ずつ読み込む。
        2.  行頭が`#`の場合、メタデータ行として解釈を試みる。
            *   `# Session Name: ...` のようなキー・バリュー形式の行をパースし、新しい`session`オブジェクトをメモリ上に構築する。
            *   キー・バリュー形式でないコメント行は無視する。
            *   カラム定義ヘッダー行 (`# timestamp...`) は、データ部のカラム順序を決定するために使用する。
        3.  行頭が`#`でない場合、データ行として解釈する。
            *   行をタブで分割し、カラム定義ヘッダーの順序に従って各値を`data_points`のフィールドにマッピングする。
            *   その際、文字列から数値への型変換を行う。
    *   **バリデーションとエラー処理:**
        *   インポート処理の前に、ファイル内容の妥当性を検証する。
        *   `Session Name`などの必須メタデータがファイルから読み取れなかった場合、ファイル名などを元にデフォルト値を設定する。
        *   データ行のカラム数がヘッダー定義と一致しない場合、その行をスキップし、処理終了後にユーザーに警告を表示する。
        *   型変換に失敗した値は `null` として扱う。

## 6. オフライン動作とPWA機能

*   **アプリケーションのキャッシュ:** Service Workerにより、アプリケーションのシェル（HTML, JS, CSS, アイコン）がキャッシュされる。これにより、オフライン時でもアプリの即時起動が可能。
*   **データの永続化:** IndexedDBはブラウザのネイティブ機能であり、オフラインでも完全に動作する。**オフライン中に記録されたデータも、正常にDBに保存される。**
*   **再オンライン時の挙動:** 特段の同期処理は不要。次にオンラインになった際に、Service Workerが新しいバージョンのアプリケーションをバックグラウンドで更新する。

## 7. 多言語化対応 (Internationalization)

### 7.1. 基本方針
アプリケーションは、複数の言語に対応可能であること。初期対応言語は日本語(`ja`)と英語(`en`)とし、将来的に他の言語も容易に追加できる設計とする。

### 7.2. 実装ライブラリ
*   `i18next` をi18nフレームワークのコアとして使用する。
*   `react-i18next` をReactコンポーネントと`i18next`を連携させるために使用する。
*   `i18next-browser-languagedetector` を導入し、ブラウザの言語設定を自動で検出する。

### 7.3. 翻訳リソース
*   **形式:** JSON形式
*   **配置場所:** `public/locales/{lng}/{namespace}.json` という構造で翻訳ファイルを配置する。これにより、アプリケーションの再ビルドなしに翻訳の追加・修正が可能となる。
    *   例: `public/locales/ja/translation.json`, `public/locales/en/translation.json`
*   **命名空間(Namespace):** 初期実装では `translation` という単一のnamespaceを使用するが、将来的な機能分割を考慮し、namespaceの利用を前提とする。

### 7.4. 言語切り替えフロー
1.  **自動検出:** アプリケーション初回起動時、`i18next-browser-languagedetector`がブラウザの言語設定 (`navigator.language`) を基に最適な言語を自動で適用する。
2.  **手動切り替え:** ユーザーはUI上の言語スイッチャー（例: 設定画面のドロップダウン）を用いて、いつでも表示言語を明示的に切り替えることができる。
3.  **設定の永続化:** ユーザーが手動で選択した言語は、`localStorage`に保存され、次回以降のアクセス時にもその設定が維持される。

### 7.5. 翻訳対象
*   UI上のすべての静的テキスト（ボタン、ラベル、メニュー項目、タイトルなど）。
*   動的に生成されるメッセージ（エラー通知、確認ダイアログなど）。
*   日付、数値、時刻のフォーマットは、言語・地域に応じて適切な形式で表示する（これは `Intl` API の範疇だが、i18nの一環として考慮する）。

## 8. エラーハンドリング

堅牢なアプリケーションのため、以下のエラーケースを想定し、適切なフィードバックをユーザーに提供する。ここで記述されるエラーメッセージは、すべて多言語化の対象となる。

*   **IndexedDB容量超過 (`QuotaExceededError`):**
    *   データの書き込み時にこのエラーを`catch`する。
    *   ユーザーに対し、「ストレージ容量が上限に達しました。不要なセッションを削除して容量を確保してください。」といった内容の永続的な通知を表示する。
*   **Web Serial API エラー:**
    *   **接続失敗時:** 「デバイスが見つかりませんでした」や「ポートへのアクセスが拒否されました」等の具体的な理由をユーザーに提示する。
    *   **測定中の切断:** 測定中に接続が切断された場合、「デバイスとの接続が切れました。再接続してください。」という通知を表示し、セッションを自動的に一時停止状態にする。
*   **ファイルインポートエラー:**
    *   ファイルが期待される`.dat` (TSV) 形式でない、スキーマが不正、などの理由でパースに失敗した場合、「ファイルの読み込みに失敗しました。サポートされている形式のファイルを選択してください。」というエラーメッセージを表示する。

## 9. 開発環境

Node.jsとpnpmが必要です。

```bash
# 1. 依存関係のインストール
pnpm install

# 2. 開発サーバーの起動
pnpm dev

# 3. 本番用ビルド
pnpm build

# 4. ビルド内容のプレビュー
pnpm preview
```

## 10. サポート＆フィードバック

*   **不具合報告:** [GitHub Issues](https://github.com/accel-kitchen/cosmicwatch-app/issues)
*   **機能要望・質問:** [GitHub Discussions](https://github.com/accel-kitchen/cosmicwatch-app/discussions)

## 11. ライセンス

このプロジェクトは [MIT License](LICENSE) の下で公開されています。